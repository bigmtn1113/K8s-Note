# 애플리케이션 배포를 위한 고급 설정

<br>

## Pod의 자원 사용량 제한
자원 활용률은 server cluster에서 자원을 얼마나 효율적으로, 빠짐없이 사용하고 있는지를 의미  
K8s는 computing 자원을 container에 할당하기 위한 여러 기능을 제공

<br>

### Container와 pod의 자원 사용량 제한 - Limit
자원 할당량을 설정하지 않으면 pod의 container가 node의 물리 자원을 모두 사용할 수 있으므로 자원이 모두 고갈되는 상황 발생 가능성 존재  

<br>

#### Pod에 자원 사용량을 명시적으로 설정
`resource-limit-pod.yaml`  
```
apiVersion: v1
kind: pod
metadata:
  name: resource-limit-pod
  lables:
    name: resource-limit-pod
spec:
  containers:
  - name: nginx
    image: nginx:latest
  resources:
    limits:
      memory: "256Mi"
      cpu: "1000m"
```

<br>

#### Worker node의 가용 자원 확인
![image](https://github.com/bigmtn1113/K8s-Note/assets/46125158/ea037ee9-d5a1-4e05-8d52-31a85eb7fe6f)

`kubectl describe node` 명령어의 출력 내용 중에서 'Non-terminated Pods' 항목에서 실행 중인 pods의 자원 할당량 확인 가능  
'Allocated resources' 항목에서는 해당 node에서 실행 중인 pods의 자원 할당량을 모두 더한 값이 표시

<br>

### Container와 pod의 자원 사용량 제한 - Request
적어도 이 만큼의 자원은 container에게 보장돼야 한다는 것을 의미

Node의 총 자원의 크기보다 더 많은 양의 requests 할당 불가  
K8s의 scheduler는 pod의 requests만큼 여유가 있는 node를 선택해 pod를 생성  
즉, pod를 할당할 때 사용되는 자원할당 기준은 limits가 아닌 requests

> **Note**  
> node에 할당된 pod의 limits 값의 합은 node의 물리 자원의 크기 초과 가능

<br>

#### Overcommit
Requests는 K8s에서 자원의 overcommit을 가능하게 만드는 기능

한정된 computing 자원을 효율적으로 사용하기 위한 방법  
사용 가능한 자원보다 더 많은 양을 가상 machine이나 container에게 할당함으로써 전체 자원의 사용률을 높이는 방법

<br>

#### Pod에 자원 사용량을 명시적으로 설정
`resource-limit-with-request-pod.yaml`
```
apiVersion: v1
kind: pod
metadata:
  name: resource-limit-with-request-pod
  lables:
    name: resource-limit-with-request-pod
spec:
  containers:
  - name: nginx
    image: nginx:latest
  resources:
    limits:
      memory: "256Mi"
      cpu: "1000m"
    requests:
      memory: "128Mi"
      cpu: "500m"
```

<br>

### CPU 자원 사용량의 제한 원리
K8s는 CPU를 압축 가능한(compressible) resource라고 지칭  
Requests보다 더 많은 CPU를 사용해 CPU 경합이 발생하더라도 container의 CPU 사용량을 throttle을 통해 억제할 수 있기 때문

Memory나 storage는 압축 불가능(incompressible)한 resource라고 지칭  
Container간에 memory 사용의 경합이 발생하면 우선순위가 낮은 container의 process가 먼저 종료되기 때문

<br>

### QoS class와 memory 자원 사용량 제한 원리
Node에 memory 자원이 부족해지면 어떤 pod나 process가 먼저 종료돼야 하는지는 상당히 중요한 부분  
K8s는 pod의 container에 설정된 limits와 requests의 값에 따라 내부적으로 우선순위를 계산

<br>

#### K8s에서의 memory 부족과 OOM(Out Of Memory)
K8s의 node에는 각종 node의 이상 상태 정보를 의미하는 Conditions라는 값이 존재  
Kubelet은 node의 자원 상태를 주기적으로 확인하면서 Conditions의 MemoryPressure, DiskPressure 등의 값을 갱신

평소에 memory가 부족하지 않을 때는 MemoryPressure의 값이 False로 되어 있으나 memory가 부족해지면 MemoryPressure의 값이 True로 변경

MemoryPressure는 기본적으로 node의 가용 memory가 100Mi 이하일 때 발생하도록 kubelet에 설정된 상태  
MemoryPressure가 발생하면 K8s는 해당 node에서 실행 중이던 모든 pod에 대해 순위를 매긴 후, 가장 우선순위가 낮은 pod를 다른 node로 퇴거(Evict).
그리고 MemoryPressure의 값이 True인 node에는 더 이상 pod를 할당하지 않음

> **Note**  
> **Hard Eviction Threshold**
>
> MemoryPressure와 같이 상태를 감지하기 위한 임계치를 Hard Eviction Threshold라고 지칭  
> kubelet의 실행 옵션에서 설정값 변경 가능  
> Hard Eviction Threshold의 다른 예시로 DiskPressure가 있으며, DiskPressure의 상태가 활성화되면 K8s는 사용 중이지 않은 docker image를 자동으로 삭제

<br>

#### QoS class의 종류 - Guaranteed class
K8s에서는 pod의 limits와 requests 값에 따라서 QoS class를 모든 pods에 대해서 설정

Guaranteed class는 pod의 container에 설정된 limits와 requests의 값이 완전히 동일할 때 부여되는 class  
Requests 없이 limits만 정의하면 requests의 값 또한 limits로 동일하게 설정  
즉, 자원의 overcommit이 허용되지 않으므로 할당받은 자원의 사용을 안정적으로 보장 가능

> **Note**  
> Pod 내의 container가 여러 개 존재한다면 모든 containers의 requests와 limits의 값이 완전히 같아야만 pod가 Guaranteed class로 분류

<br>

#### QoS class의 종류 - BestEffort class
